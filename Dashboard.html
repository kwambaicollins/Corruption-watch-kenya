<!DOCTYPE html>
<html lang="en">
<head>
    <!-- ... [Your head content as provided] ... -->
</head>
<body>
    <!-- ... [Your dashboard HTML markup as provided] ... -->

    <!-- Firebase SDKs -->
    <script type="module">
        // Firebase module imports (version 9+ modular syntax)
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";
        import { getDatabase, ref, get, child, onValue } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-database.js";

        // Your Firebase config
        const firebaseConfig = {
            apiKey: "AIzaSyD7NFb1hFX3VFzfbJ0UmY-mDby-6w3MYuk",
            authDomain: "corruption-watch-kenya.firebaseapp.com",
            databaseURL: "https://corruption-watch-kenya-default-rtdb.firebaseio.com",
            projectId: "corruption-watch-kenya",
            storageBucket: "corruption-watch-kenya.appspot.com",
            messagingSenderId: "1032330075769",
            appId: "1:1032330075769:web:6e5f0d984d95cec8c5bea8",
            measurementId: "G-TZJZCMY0ME"
        };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);

        // Chart.js and map globals
        let typeChart, trendChart, statusChart, heatmap;
        let allReportsData = [];

        document.addEventListener('DOMContentLoaded', async function() {
            initMap();
            initCharts();
            await loadDashboardData();

            document.getElementById('refreshBtn').addEventListener('click', loadDashboardData);
            document.querySelectorAll('.filters select').forEach(sel => sel.addEventListener('change', loadDashboardData));
        });

        // Initialize Leaflet map
        function initMap() {
            heatmap = L.map('heatmap').setView([0.0236, 37.9062], 6);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '&copy; OpenStreetMap contributors'
            }).addTo(heatmap);
        }

        // Initialize Chart.js charts
        function initCharts() {
            // ... [Same as your chart initialization code] ...
            const typeCtx = document.getElementById('typeChart').getContext('2d');
            typeChart = new Chart(typeCtx, { type: 'doughnut', data: { labels: [], datasets: [{ data: [], backgroundColor: [] }] } });
            const trendCtx = document.getElementById('trendChart').getContext('2d');
            trendChart = new Chart(trendCtx, { type: 'line', data: { labels: [], datasets: [{ data: [], borderColor: '#006341' }] } });
            const statusCtx = document.getElementById('statusChart').getContext('2d');
            statusChart = new Chart(statusCtx, { type: 'bar', data: { labels: [], datasets: [{ data: [], backgroundColor: [] }] } });
        }

        // --- DATA LOADING AND ANALYSIS FUNCS ---

        // Main data loader
        async function loadDashboardData() {
            showLoading(true);
            try {
                // Fetch all reports
                const snapshot = await get(child(ref(db), 'reports'));
                if (!snapshot.exists()) {
                    allReportsData = [];
                } else {
                    // Convert to array, append key as id
                    allReportsData = Object.entries(snapshot.val()).map(([id, r]) => ({ id, ...r }));
                }

                // Filter client-side according to UI
                const filters = {
                    timePeriod: document.getElementById('timePeriod').value,
                    corruptionType: document.getElementById('corruptionType').value,
                    status: document.getElementById('status').value
                };
                let filtered = applyFilters(allReportsData, filters);

                // Stats and chart building
                updateStats(computeStats(filtered));
                updateTypeChart(getTypeDist(filtered));
                updateTrendChart(getMonthlyTrend(filtered));
                updateStatusChart(getStatusDist(filtered));
                updateHeatmap(getHeatmapData(filtered));
                updateRecentReports(filtered);

            } catch (e) {
                console.error('Dashboard error:', e);
                alert('Error loading data from Firebase.');
            } finally {
                showLoading(false);
            }
        }

        // Data helpers
        function applyFilters(data, { timePeriod, corruptionType, status }) {
            const now = new Date();
            return data.filter(report => {
                // Time filter
                if (timePeriod !== 'all') {
                    const days = { "7days": 7, "30days": 30, "90days": 90 }[timePeriod];
                    if (days) {
                        const reportDate = new Date(report.created_at);
                        if ((now - reportDate) > days*24*60*60*1000) return false;
                    }
                }
                // Corruption type filter
                if (corruptionType !== 'all' && report.corruption_type !== corruptionType) return false;
                // Status filter
                if (status !== 'all' && normalizeStatus(report.status) !== status) return false;
                return true;
            });
        }

        function normalizeStatus(status) {
            if (status === 'under_investigation') return 'investigating';
            if (status === 'pending') return 'pending';
            if (status === 'resolved') return 'resolved';
            return 'pending';
        }

        function computeStats(reports) {
            const total = reports.length;
            let underInvestigation=0, resolved=0, pending=0;
            let locationMap = {};
            reports.forEach(r => {
                const normStat = normalizeStatus(r.status);
                if (normStat === 'investigating') underInvestigation++;
                else if (normStat === 'resolved') resolved++;
                else pending++;
                locationMap[r.location||'Unknown'] = (locationMap[r.location||'Unknown']||0)+1;
            });
            // Hotspots: regions with counts above mean+stddev, or just top-N.
            const regionCounts = Object.values(locationMap);
            let hotspots = 0;
            if (regionCounts.length) {
                const avg = regionCounts.reduce((a,b)=>a+b,0)/regionCounts.length;
                const stddev = Math.sqrt(regionCounts.reduce((a,b)=>a+(b-avg)**2,0)/regionCounts.length);
                hotspots = regionCounts.filter(c => c >= avg+stddev).length;
            }
            return { total, underInvestigation, resolved, pending: hotspots };
        }

        function getTypeDist(reports) {
            const types = {}, colors = { bribery:'#FFD600', embezzlement:'#E57373', nepotism:'#64B5F6', fraud:'#81C784', other:'#9E9E9E' };
            reports.forEach(r => {
                const k = r.corruption_type || 'other';
                types[k] = (types[k]||0)+1;
            });
            const labels = Object.keys(types);
            const data = labels.map(k=>types[k]);
            const backgroundColor = labels.map(k => colors[k] || '#BBB');
            return { labels, data, backgroundColor };
        }

        function getStatusDist(reports) {
            const stats = {}; const colorMap={pending:'#FFD600', investigating:'#64B5F6', resolved:'#81C784'};
            reports.forEach(r => {
                const k = normalizeStatus(r.status);
                stats[k] = (stats[k]||0)+1;
            });
            const labels = Object.keys(stats);
            const data = labels.map(k=>stats[k]);
            const backgroundColor = labels.map(k=>colorMap[k] || '#BBB');
            return { labels, data, backgroundColor };
        }

        function getMonthlyTrend(reports) {
            // Group by months (YYYY-MM)
            const counts = {};
            reports.forEach(r => {
                const d = new Date(r.created_at);
                const k = `${d.getFullYear()}-${(d.getMonth()+1).toString().padStart(2,'0')}`;
                counts[k] = (counts[k]||0)+1;
            });
            const sortedMonths = Object.keys(counts).sort();
            const data = sortedMonths.map(m=>counts[m]);
            return { labels: sortedMonths, data };
        }

        function getHeatmapData(reports) {
            // Returns array of [lat, lng, intensity]
            return reports
                .filter(r => r.latitude && r.longitude)
                .map(r => [Number(r.latitude), Number(r.longitude), 1]);
        }

        // --- DASHBOARD UI UPDATERS (as in your code) ---
        function updateStats(stats) {
            document.getElementById('totalReports').textContent = stats.total.toLocaleString();
            document.getElementById('investigating').textContent = stats.underInvestigation.toLocaleString();
            document.getElementById('resolved').textContent = stats.resolved.toLocaleString();
            document.getElementById('hotspots').textContent = stats.pending.toLocaleString();
        }
        function updateTypeChart(typeData) {
            typeChart.data.labels = typeData.labels;
            typeChart.data.datasets[0].data = typeData.data;
            typeChart.data.datasets[0].backgroundColor = typeData.backgroundColor;
            typeChart.update();
        }
        function updateTrendChart(trendData) {
            trendChart.data.labels = trendData.labels;
            trendChart.data.datasets[0].data = trendData.data;
            trendChart.update();
        }
        function updateStatusChart(statusData) {
            statusChart.data.labels = statusData.labels;
            statusChart.data.datasets[0].data = statusData.data;
            statusChart.data.datasets[0].backgroundColor = statusData.backgroundColor;
            statusChart.update();
        }
        function updateHeatmap(heatmapData) {
            if (window.heatmapLayer) {
                heatmap.removeLayer(window.heatmapLayer);
            }
            if (heatmapData && heatmapData.length > 0) {
                window.heatmapLayer = L.heatLayer(heatmapData, {
                    radius: 25, blur: 15, maxZoom: 17, gradient: {0.4:'blue',0.6:'lime',0.8:'yellow',1.0:'red'}
                }).addTo(heatmap);
            }
        }
        function updateRecentReports(reports) {
            const tableBody = document.querySelector('#reportsTable tbody');
            tableBody.innerHTML = '';
            const recentReports = [...reports].sort((a,b)=>new Date(b.created_at)-new Date(a.created_at)).slice(0,10);
            recentReports.forEach(report => {
                const row = document.createElement('tr');
                let statusBadge;
                const normStat = normalizeStatus(report.status);
                if (normStat === 'pending') statusBadge = `<span class="status-badge status-pending">Pending</span>`;
                else if (normStat === 'investigating') statusBadge = `<span class="status-badge status-investigating">Investigating</span>`;
                else statusBadge = `<span class="status-badge status-resolved">Resolved</span>`;
                const shortDescription = (report.description||'').length > 50 ? `${report.description.substring(0, 50)}...` : (report.description||'');
                row.innerHTML = `
                    <td>CWK-${report.id || 'N/A'}</td>
                    <td>${report.corruption_type||'N/A'}</td>
                    <td>${shortDescription}</td>
                    <td>${report.location||'N/A'}</td>
                    <td>${report.created_at ? new Date(report.created_at).toLocaleDateString() : 'N/A'}</td>
                    <td>${statusBadge}</td>
                `;
                tableBody.appendChild(row);
            });
        }
        function showLoading(show) {
            document.getElementById('loadingIndicator').style.display = show ? 'block' : 'none';
            document.getElementById('dashboardContent').style.display = show ? 'none' : 'block';
        }
    </script>
    <!-- Your scripts for Chart.js, Leaflet, etc. -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
</body>
</html>
